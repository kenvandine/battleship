#!/usr/bin/env python3
"""
Command‚Äëline Battleship client.

Commands
--------
battleship start                 ‚Üí create a new game, store token locally
battleship join <game_id>        ‚Üí join an existing game, store token locally
battleship status                ‚Üí show current board & whose turn it is
battleship fire <coord>          ‚Üí fire at opponent (e.g. "E7")
"""

import sys, os, json, pathlib, requests
from urllib.parse import urljoin

_raw_url = os.getenv(
    "SERVER_URL",
    "http://localhost:5000/"
)
# Ensure the SERVER_URL ends with a slash
SERVER_URL = _raw_url.rstrip("/") + "/"
TOKEN_FILE = pathlib.Path.home() / ".battleship" / "current"

EMOJI = {
    "unknown": "‚ùì",
    "miss":    "‚ö™",
    "hit":     "üí•",   # opponent hit on opponent board
    "ship":    "üö¢",   # your own healthy ship segment
    "ship_hit":"üî•",   # your own ship segment that the opponent has hit
}

BOARD_SIZE = 12

def _ensure_dir():
    TOKEN_FILE.parent.mkdir(parents=True, exist_ok=True)

def _save_token(game_id, token):
    _ensure_dir()
    data = {"game_id": game_id, "token": token}
    TOKEN_FILE.write_text(json.dumps(data))

def _load_token():
    if not TOKEN_FILE.is_file():
        return None
    try:
        return json.loads(TOKEN_FILE.read_text())
    except Exception:
        return None

def _clear_token():
    if TOKEN_FILE.is_file():
        TOKEN_FILE.unlink()

def _fetch_state(game_id, token):
    """
    Pull the game state from the server, passing our token so we can
    receive our private board.
    """
    url = f"{SERVER_URL}games/{game_id}/state?token={token}"
    resp = requests.get(url)
    if not resp.ok:
        print(f"Error fetching state: {resp.text}", file=sys.stderr)
        sys.exit(1)
    return resp.json()

# -----------------------------------------------------------------
# Board rendering ‚Äì now works for a 12√ó12 board
# -----------------------------------------------------------------
def _print_board(state, my_token):
    """
    Render a 12√ó12 grid.

    - üö¢  : your ship segment that hasn't been hit.
    - üî•  : your ship segment that the opponent has already hit.
    - üí•  : a hit you scored on the opponent.
    - ‚ö™  : a miss you scored on the opponent.
    - ‚ùì  : unknown / water.
    """
    # Empty visual grid
    grid = [[EMOJI["unknown"] for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]

    # Opponent‚Äëside hits/misses (if opponent exists)
    player_tokens = list(state["players"].keys())
    try:
        opponent_token = next(t for t in player_tokens if t != my_token)
        opponent_exists = True
    except StopIteration:
        opponent_token = None
        opponent_exists = False

    if opponent_exists:
        opp_data = state["players"][opponent_token]

        for coord in opp_data["hits"]:
            col = ord(coord[0]) - ord('A')
            row = int(coord[1:]) - 1
            grid[row][col] = EMOJI["hit"]          # üí•

        for coord in opp_data["misses"]:
            col = ord(coord[0]) - ord('A')
            row = int(coord[1:]) - 1
            grid[row][col] = EMOJI["miss"]         # ‚ö™

    # Overlay YOUR own ships and mark any hits the opponent already made
    private_board = state.get("private_board")
    if private_board:
        opponent_hits = set()
        if opponent_exists:
            opponent_hits = set(state["players"][my_token]["hits"])

        for r in range(BOARD_SIZE):
            for c in range(BOARD_SIZE):
                cell = private_board[r][c]
                if cell != "~":                     # there is a ship here
                    coord = f"{chr(ord('A')+c)}{r+1}"
                    if coord in opponent_hits:
                        grid[r][c] = EMOJI["ship_hit"]   # üî•
                    else:
                        if grid[r][c] == EMOJI["unknown"]:
                            grid[r][c] = EMOJI["ship"]   # üö¢

    # Header line (aligned with cells)
    col_header = "   " + " ".join(chr(ord('A') + i) + " " for i in range(BOARD_SIZE))
    print(col_header.rstrip())

    # Rows (right‚Äëaligned row numbers)
    for r in range(BOARD_SIZE):
        row_label = f"{r+1:2d}"
        row_cells = " ".join(grid[r]) + " "
        print(f"{row_label} {row_cells.rstrip()}")

    # If opponent hasn't joined yet, show a friendly note.
    if not opponent_exists:
        print("\nüïí Waiting for the opponent to join this game...")

def _api(path, method="GET", json_body=None):
    url = urljoin(SERVER_URL, path)
    resp = requests.request(method, url, json=json_body)
    if not resp.ok:
        print(f"Error {resp.status_code}: {resp.text}", file=sys.stderr)
        sys.exit(1)
    return resp.json()

def cmd_start(_):
    # Create game
    data = _api("games/start", "POST")
    game_id = data["game_id"]
    # Join as first player
    join = _api(f"games/{game_id}/join", "POST")
    token = join["token"]
    _save_token(game_id, token)
    print(f"New game created! ID = {game_id}")
    print(f"Your token is stored at {TOKEN_FILE}")

def cmd_join(args):
    if len(args) != 1:
        print("Usage: battleship join <GAME_ID>")
        sys.exit(1)
    game_id = args[0]
    join = _api(f"games/{game_id}/join", "POST")
    token = join["token"]
    _save_token(game_id, token)
    print(f"Joined game {game_id}. Token saved to {TOKEN_FILE}")

def cmd_status(_):
    cur = _load_token()
    if not cur:
        print("No active game. Use 'battleship start' or 'battleship join <id>'.")
        return

    state = _fetch_state(cur["game_id"], cur["token"])
    print(f"Game ID: {cur['game_id']}")
    print(f"Turn: {'you' if state['turn'] == cur['token'] else 'opponent'}")
    _print_board(state, cur["token"])

    damaged = _list_my_damaged_ships(state, cur["token"])
    if damaged:
        print("\nYour ships that have been hit:", ", ".join(damaged))
    else:
        print("\nAll your ships are still intact.")

def cmd_fire(args):
    if len(args) != 1:
        print("Usage: battleship fire <COORD>")
        sys.exit(1)

    coord = args[0].upper()
    cur = _load_token()
    if not cur:
        print("No active game.")
        sys.exit(1)

    # Verify it's our turn first
    state = _fetch_state(cur["game_id"], cur["token"])
    if state["turn"] != cur["token"]:
        print("It's not your turn yet.")
        return

    payload = {"token": cur["token"], "coord": coord}
    resp = requests.post(f"{SERVER_URL}games/{cur['game_id']}/move", json=payload)
    if not resp.ok:
        print(f"Move failed: {resp.text}")
        return

    result = resp.json()
    # -----------------------------------------------------------------
    # Basic hit / miss output
    # -----------------------------------------------------------------
    print(f"You fired at {coord}: {result['result'].upper()}")

    # -----------------------------------------------------------------
    # Did we sink something?
    # -----------------------------------------------------------------
    if result.get("sunk"):
        sunk_name = result.get("sunk_name") or "a ship"
        print(f"üéâ You SUNK the opponent's {sunk_name}! üéâ")

    # -----------------------------------------------------------------
    # Refresh board (shows your own ships, hits on them, etc.)
    # -----------------------------------------------------------------
    new_state = _fetch_state(cur["game_id"], cur["token"])
    _print_board(new_state, cur["token"])

def cmd_help(_):
    """
    Display a quick reference for all commands and the emoji legend.
    """
    # ---------------------------- Commands ---------------------------------
    commands_desc = [
        ("start",   "Create a brand‚Äënew game and store the token locally."),
        ("join ID", "Join an existing game identified by <ID>. Saves its token."),
        ("status",  "Show the current board, whose turn it is, and which of your "
                    "ships have been hit."),
        ("fire XY", "Fire a shot at coordinate XY (e.g. B5). Must be your turn."),
        ("quit",    "Forget the locally‚Äësaved token ‚Äì useful if you want to "
                    "switch to a different game."),
        ("help",    "Show this help screen."),
    ]

    print("\n=== Battleship ‚Äì command reference ===\n")
    for cmd, desc in commands_desc:
        print(f"  {cmd:<12} {desc}")

    # ---------------------------- Emoji legend ----------------------------
    legend = [
        ("üö¢", "Your ship segment (still afloat)"),
        ("üî•", "Your ship segment that the opponent has hit"),
        ("üí•", "A hit you scored on the opponent"),
        ("‚ö™", "A miss you scored on the opponent"),
        ("‚ùì", "Unknown / water (no information yet)"),
    ]

    print("\n=== Emoji legend ===\n")
    for emoji, meaning in legend:
        print(f"  {emoji}  ‚Äì {meaning}")

    print("\nTip: Run `battleship help` anytime to see this again.\n")

def _list_my_damaged_ships(state, my_token):
    """
    Returns a list of ship letters that have at least one hit on them.
    """
    private_board = state.get("private_board")
    if not private_board:
        return []

    # Opponent's hits against us
    opponent_hits = set(state["players"][my_token]["hits"])
    damaged = set()
    for coord in opponent_hits:
        col = ord(coord[0]) - ord('A')
        row = int(coord[1:]) - 1
        ship_letter = private_board[row][col]
        if ship_letter != "~":
            damaged.add(ship_letter)

    # Friendly names (same mapping used on the server)
    names = {
        "A": "Aircraft Carrier",
        "B": "Battleship",
        "S": "Submarine",
        "D": "Destroyer",
        "P": "Patrol Boat",
    }
    return [names.get(l, l) for l in sorted(damaged)]

def cmd_quit(_):
    _clear_token()
    print("Current game cleared from local storage.")

def main():
    if len(sys.argv) < 2:
        cmd_help(None)
        sys.exit(0)

    cmd = sys.argv[1]
    args = sys.argv[2:]

    commands = {
        "start":  cmd_start,
        "join":   cmd_join,
        "status": cmd_status,
        "fire":   cmd_fire,
        "quit":   cmd_quit,
        "help":   cmd_help,          # <-- NEW ENTRY
    }

    if cmd not in commands:
        print(f"Unknown command '{cmd}'. Available: {', '.join(commands)}")
        sys.exit(1)

    commands[cmd](args)

if __name__ == "__main__":
    main()
